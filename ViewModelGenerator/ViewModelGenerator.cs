using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Linq;
using System.Text;

namespace ViewModelGenerator;

[Generator]
public class ViewModelGenerator : IIncrementalGenerator
{
    //Get classes ViewModel attribute
    //Create partial class the inherits from BaseViewModel with the name of the class
    //Get methods in viewmodel with command attribute
    //Create new command class with name of method that calls method on execute and inherits from BaseCommand.
    //?? Figure out how to handle CanExecute cleanly ??
    //
    //Get properties in viewmodel with bind attribute
    //Create a new ObservableProperty with a get/set to the property name

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var viewModelCandidates = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax,
                transform: static (ctx, _) => (ClassDeclarationSyntax)ctx.Node)
            .Where(static cls => cls.AttributeLists.Count > 0);

        var compilationAndClasses = context.CompilationProvider.Combine(viewModelCandidates.Collect());

        context.RegisterSourceOutput(compilationAndClasses, static (spc, source) =>
        {
            var (compilation, classNodes) = source;

            foreach (var classNode in classNodes)
            {
                var model = compilation.GetSemanticModel(classNode.SyntaxTree);
                if (model.GetDeclaredSymbol(classNode) is not INamedTypeSymbol symbol) continue;

                if (!symbol.GetAttributes().Any(attr => attr.AttributeClass?.Name == "ViewModelAttribute")) continue;

                var className = symbol.Name;
                var generatedName = $"{className}";
                var namespaceName = symbol.ContainingNamespace.ToDisplayString();

                var bindFields = symbol.GetMembers()
                    .OfType<IFieldSymbol>()
                    .Where(f => f.GetAttributes().Any(attr => attr.AttributeClass?.Name == "BindAttribute"))
                    .ToList();

                var commandMethods = symbol.GetMembers()
                    .OfType<IMethodSymbol>()
                    .Where(m => m.MethodKind == MethodKind.Ordinary &&
                                m.GetAttributes().Any(attr => attr.AttributeClass?.Name == "CommandAttribute"))
                    .ToList();

                // Generate ViewModel partial class
                var viewModelBuilder = new StringBuilder(
$@"// <auto-generated />
#nullable enable
using SimpleViewModel.BaseClasses;

namespace {namespaceName}
{{
    public partial class {className} : BaseViewModel
    {{
");
                foreach (var field in bindFields)
                {
                    var fieldType = field.Type.ToDisplayString();
                    var fieldName = ToPascal(field.Name);

                    viewModelBuilder.AppendLine(
$@"        public {fieldType} {fieldName} {{ get => {field.Name}; 
            set 
            {{
                SetProperty(ref {field.Name}, value);");

                    var onChange = GetOnChangeMethodName(field);
                    if (!string.IsNullOrWhiteSpace(onChange))
                        viewModelBuilder.AppendLine($"          {onChange}();");
                    viewModelBuilder.AppendLine("        }}");
                }
                //viewModelBuilder.AppendLine("    }"); // <-- FIX: close property

                foreach (var method in commandMethods)
                {
                    var commandClassName = $"Command_{method.Name}";
                    var commandFieldName = $"{ToPascal(method.Name)}Command";
                    viewModelBuilder.AppendLine($"        private {commandClassName}? _{commandFieldName} {{ get; set; }}");
                    viewModelBuilder.AppendLine($"        public {commandClassName} {commandFieldName} => _{commandFieldName} ??= new(this);");

                    // Check for AcceptParameter property on CommandAttribute
                    var acceptParameter = method.GetAttributes()
                        .FirstOrDefault(attr => attr.AttributeClass?.Name == "CommandAttribute")?
                        .NamedArguments.FirstOrDefault(arg => arg.Key == "AcceptParameter").Value.Value as bool? ?? false;

                    // Check if method has a single parameter
                    var hasParameter = method.Parameters.Length == 1;
                    var paramType = hasParameter ? method.Parameters[0].Type.ToDisplayString() : null;

                    // Generate command class per method
                    var isAsync = IsAsyncTask(method);
                    var commandBuilder = new StringBuilder(
$@"// <auto-generated />
#nullable enable
using SimpleViewModel.BaseClasses;

namespace {namespaceName}
{{
    public sealed class {commandClassName} : BaseCommand
    {{
        private readonly {className} vm;

        public {commandClassName}({className} vm)
        {{
            this.vm = vm;
        }}

        public override {(isAsync ? "async void" : "void")} Execute(object? parameter)
        {{
");
                    commandBuilder.AppendLine("            try");
                    commandBuilder.AppendLine("            {");

                    if (acceptParameter && hasParameter)
                    {
                        if (isAsync)
                            commandBuilder.AppendLine($"                await vm.{method.Name}(({paramType})parameter!);");
                        else
                            commandBuilder.AppendLine($"                vm.{method.Name}(({paramType})parameter!);");
                    }
                    else
                    {
                        if (isAsync)
                            commandBuilder.AppendLine($"                await vm.{method.Name}();");
                        else
                            commandBuilder.AppendLine($"                vm.{method.Name}();");
                    }

                    commandBuilder.AppendLine("            }");
                    commandBuilder.AppendLine("            catch (Exception ex)");
                    commandBuilder.AppendLine("            {");
                    commandBuilder.AppendLine("                vm.OnCommandException(ex);");
                    commandBuilder.AppendLine("            }");

                    commandBuilder.AppendLine("        }");
                    var canExecute = GetCanExecuteMethodName(method);
                    if (!string.IsNullOrWhiteSpace(canExecute))
                        commandBuilder.AppendLine($"        public override bool CanExecute(object? parameter) => vm.{canExecute}();");
                    commandBuilder.AppendLine("    }");
                    commandBuilder.AppendLine("}");
                    spc.AddSource($"{commandClassName}.g.cs", SourceText.From(commandBuilder.ToString(), Encoding.UTF8));
                }

                viewModelBuilder.AppendLine("    }");
                viewModelBuilder.AppendLine("}");

                spc.AddSource($"{generatedName}.g.cs", SourceText.From(viewModelBuilder.ToString(), Encoding.UTF8));
            }
        });
    }

    private static string ToPascal(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        if (name.StartsWith("_")) name = name.TrimStart('_');
        return char.ToUpperInvariant(name[0]) + name.Substring(1);
    }

    private static string? GetCanExecuteMethodName(IMethodSymbol method)
    {
        foreach (var attr in method.GetAttributes())
        {
            if (attr.AttributeClass?.Name == "CommandAttribute")
            {
                foreach (var namedArg in attr.NamedArguments)
                {
                    if (namedArg.Key == "CanExecuteMethodName")
                    {
                        return namedArg.Value.Value?.ToString();
                    }
                }
            }
        }
        return null;
    }

    private static string? GetOnChangeMethodName(IFieldSymbol field)
    {
        foreach (var attr in field.GetAttributes())
        {
            if (attr.AttributeClass?.Name == "BindAttribute")
            {
                foreach (var namedArg in attr.NamedArguments)
                {
                    if (namedArg.Key == "OnChangeMethodName")
                    {
                        return namedArg.Value.Value?.ToString();
                    }
                }
            }
        }
        return null;
    }

    private static bool IsAsyncTask(IMethodSymbol method)
    {
        var returnType = method.ReturnType;

        if (returnType is INamedTypeSymbol named)
        {
            if (named.Name == "Task" &&
                named.ContainingNamespace.ToDisplayString() == "System.Threading.Tasks")
                return true;
        }

        return false;
    }
}
